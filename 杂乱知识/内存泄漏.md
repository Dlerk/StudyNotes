# 内训泄露 Memory Leak

&emsp;内存泄漏（ Memory Leak ）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

### 内存泄漏与内存溢出的关系

内存溢出：
> 申请内存时，没有足够的内存可以使用

内存泄漏的增多，最终会导致内存溢出。

### 造成内存泄漏的常见4种情况

1. 指针重新赋值

如下代码：
```cpp
char * p = (char *)malloc(10);
char * np = (char *)malloc(10);
```

如果程序需要执行如下赋值语句：
```cpp
p=np;
```

&emsp;这时候，指针变量 p 被 np 指针重新赋值，其结果是 p 以前所指向的内存位置变成了孤立的内存。它无法释放，因为没有指向该位置的引用，从而导致 10 字节的内存泄漏。

`因此，在对指针赋值前，一定确保内存位置不会变为孤立的。`

类似的情况，连续重复new的情况也是类似：
```cpp
 int *p = new int; 
 p = new int...;    // 导致内存泄漏
```

2. 错误的内存释放

&emsp;假设有一个指针变量 p，它指向一个 10 字节的内存位置。该内存位置的第三个字节又指向某个动态分配的 10 字节的内存位置。

如果程序需要执行如下赋值语句时：
```cpp
free(p);
```

&emsp;很显然，如果通过调用 free 来释放指针 p，则 np 指针也会因此而变得无效。np 以前所指向的内存位置也无法释放，因为已经没有指向该位置的指针。换句话说，np 所指向的内存位置变为孤立的，从而导致内存泄漏。

&emsp;因此，每当释放结构化的元素，而该元素又包含指向动态分配的内存位置的指针时，应首先遍历子内存位置（如本示例中的 np），并从那里开始释放，然后再遍历回父节点。

如下面的代码所示：
```cpp
free(p->np);
free(p);
```

3. 返回值的不正确处理

有时候，某些函数会返回对动态分配的内存的引用，如下面的示例代码所示：
```cpp
char *f()
{
	return (char *)malloc(10);
}

void f1()
{
	f();
}
```

&emsp;函数 f1 中对 f 函数的调用并未处理该内存位置的返回地址，其结果将导致 f 函数所分配的 10 个字节的块丢失，并导致内存泄漏。

4. 在内存分配后忘记使用`free`或`delete`进行释放

### 如何避免内存泄漏

+ 确保没有在访问空指针。
+ 每个内存分配函数都应该有一个 free 函数与之对应，alloca 函数除外。
+ 每次分配内存之后都应该及时进行初始化，可以结合 memset 函数进行初+ 始化，calloc 函数除外。
+ 每当向指针写入值时，都要确保对可用字节数和所写入的字节数进行交叉核对。
+ 在对指针赋值前，一定要确保没有内存位置会变为孤立的。
+ 每当释放结构化的元素（而该元素又包含指向动态分配的内存位置的指针）时，都应先遍历子内存位置并从那里开始释放，然后再遍历回父节点。
+ 始终正确处理返回动态分配的内存引用的函数返回值。
